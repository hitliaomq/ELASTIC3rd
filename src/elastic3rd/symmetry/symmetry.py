#!python
#filename: symmetry.py
#function: generate the strain patterns 
#          for calculating third-order elastic constant using strain-energy method
#author: Mingqing Liao
#e-mail: liaomq1900127@163.com
#FGMS group @ Harbin Institute of Technology(HIT)

from itertools import combinations, product
import elastic3rd.crystal.deform as crydef
import numpy as np
import math
import elastic3rd.symmetry.symdata as symdata

def gen_strain(strain_sca, straincomb=[1.0, 0.5]):
    '''
    Generate all combinations of strain modes containing 0 and elements in straincomb
    Parameter
    ---------
        strain_sca: float
            The amplitude of the strain modes
        straincomb: list
            The elements contains in the strain modes
            e.g. [1.0, 0.5] means the generated strain modes will contain elements only [0, 1.0, 0.5]
                e.g. [1, 0, 0, 0, 0, 0] or [1, 0.5, 0, 0, 0, 0] or ...
    Return
    ------
        Strain: np.ndarray
            The list of all strain modes
    '''
    strain_sca = float(strain_sca)
    Strain = np.array([[0, 0, 0, 0, 0, 0]])
    for i in range(1, 7):
        straini = list(combinations([0, 1, 2, 3, 4, 5], i))
        for j in range(0, len(straini)):
            straintmp = np.array([[0, 0, 0, 0, 0, 0]], dtype = float)
            strainindex = np.array(straini[j], dtype = int)
            #strainprod = list(product([strain_sca], repeat=i))
            straincombination = [strain_sca*combi for combi in straincomb]
            strainprod = list(product(straincombination, repeat=i))
            for k in range(0, len(strainprod)):
                strainprodk = np.array(strainprod[k])
                #print strainprodk
                straintmp[0, strainindex] = strainprodk         
                straintmp[0, 3:] = 2 * straintmp[0, 3:]
                Strain = np.append(Strain, straintmp, axis = 0)
    #Strain = np.append(Strain, np.array([[1, 0.5, 0, 0, 0, 0]]), axis = 0)
    Strain = np.delete(Strain, 0, 0)
    return Strain

def Num2IJK(Num, N=6, Ord=3):
    '''
    This function convert numbers to IJK index
        Note: This is for full elastic constant, not only the independent one. 
            e.g. for C44, the Num should be 22, not 16 (independent one)
    Parameter
    ---------
        Num: int
            The number to be convert, in base of 10
        N: int
            The new base N, larger than 1. Note, in the calculation of elastic constant, it should always be 6
        Ord: int
            The Order of elastic constants
    
    **Note:** The first number is [111](The number is determined by Ord) not [000]
    '''
    IJK = np.zeros(int(Ord), dtype=int)
    for i in range(int(Ord), 0, -1):
        k = i - 1
        DivNum = N ** k
        IJK[int(Ord) - 1 - k] = math.ceil(float(Num) / float(DivNum))
        if IJK[int(Ord) - 1 -k] > N:
            raise IndexError('ERROR')
        #print Ord - 1 - k
        Num = Num % DivNum
        if Num == 0:
            #IJK[Ord - 1 - k] = IJK[Ord - 1 - k] - 1
            for j in range(int(Ord) - k, int(Ord)):
                #print j
                IJK[j] = N
            return IJK
    return IJK

def gen_strain_coef(StrainOrd, StrainOrdCoef, Ord=3):
    '''
    Get the non-zero second- or third- (specified by the Ord parameter) 
        elastic constants and corresponding coefficients according to strain mode
    Parameter
    ---------
        Note: The input parameters can be generated by gen_strainord
        StrainOrd: list
            The Voigt's index of non-zeros elements
        StrainOrdCoef: list
            The value of non-zeros elements
        Ord: inst
            The order of elastic constants (no more thant 9th order)
    Return
    ------
        CoefUniq: 1D np.ndarray
            The list of non-zero elastic constants (Note: the symmetry is not applied here)
        CoefUniqCoef: 1D np.ndarray
            The coefficient of CoefUniq
    '''
    n_strain = len(StrainOrd)
    N = int(n_strain ** Ord)
    #flag = 0
    Coef = np.ones(N)
    Cijk = np.zeros(N)
    for i in range(0, N):
        IJK = Num2IJK(i + 1, n_strain, Ord)
        #print IJK
        coeftmp = np.zeros(int(Ord))
        for i_ord in range(0, int(Ord)):
            #print IJK[i_ord]
            coeftmp[i_ord] = StrainOrd[IJK[i_ord] - 1]
        coeftmp = np.sort(coeftmp)
        #print coeftmp
        for j in range(0, int(Ord)):
            Cijk[i] = Cijk[i] + coeftmp[j] * (10 ** (Ord - 1 - j))
            Coef[i] = Coef[i] * StrainOrdCoef[IJK[j] - 1]
    CoefUniq, CoefIndex = np.unique(Cijk, return_index=True)
    #print len(CoefUniq)
    Coef = Coef[CoefIndex]
    CoefUniqCoef = np.zeros(len(CoefUniq))
    for i in range(0, len(CoefUniq)):
        CoefUniqCoef[i] = sum(Cijk == CoefUniq[i])
    CoefUniqCoef = CoefUniqCoef * Coef
    return (CoefUniq, CoefUniqCoef)

def gen_strainord(strain):
    #function: get the non-zero elements in the strain tensor(StrainOrd)
    #          and get the corresponding coefficients(StrainOrdCoef)
    '''
    Get the index (in Voigt's notation) non-zeros elements and corresponding coefficients in the strain matrix (strain)
    Parameter
    ---------
        strain: np.ndarray
            strain matrix, 3x3
    Return
    ------
        StrainOrd: list
            The Voigt's index of non-zeros elements
        StrainOrdCoef: list
            The value of non-zeros elements
    E.g.
    ----
        strain = np.array([[0.1, 0, 0], [0, 0.1, 0.1], [0, 0.1, 0]])
        Return:
            StrainOrd = [1, 2, 4, 4]
            StrainOrd = [0.1, 0.1, 0.1, 0.1]
    '''
    StrainOrd = []
    StrainOrdCoef = []
    if crydef.is_strain_matrix(strain):
        for i in range(0, 3):
            for j in range(0, 3):
                if not (strain[i, j] == 0):
                    StrainOrd.append(voigtmap(i+1, j+1))
                    StrainOrdCoef.append(float(strain[i][j]))
    else:
        raise IOError("The input strain matrix is not symmetry.")
    return (StrainOrd, StrainOrdCoef)

def voigtmap(i, j):
    '''
    Convert i,j pair to single value using Voigt's notation
    Parameter
    ---------
        i,j: int
            The tensor index. Note: both i and j range from 1 to 3
    Return
    ------
        voigt: int
            Voigt index, ranging from 1 to 6
    '''
    if i * j == 1:
        voigt = 1
    elif i * j == 4:
        voigt = 2
    elif i * j == 9:
        voigt = 3
    elif i * j == 6:
        voigt = 4
    elif i * j == 3:
        voigt = 5
    elif i * j == 2:
        voigt = 6
    else:
        voigt = 0
        IOError("Both i and j should range from 1 to 3")
        print("ERROR: Both i and j shold range from 1 to 3.")
    return voigt

def gen_cijk_coef(CrystalType='c1', Strain=np.array([[1,0,0],[0,1,1],[0,1,0]]), Ord=3):
    '''
    Generate the coefficients of independent elastic constants 
        according to symmetry and strain and elastic constants order
    Parameter
    ---------
        CrystalType: str
            The crystal type, in Laue group
        Strain: 2D np.ndarray
            The strain in matrix/tensor format
        Ord: int
            The order of elasti constants
    Return
    ------
        CoefStrain: 1D np.ndarray
            The coefficients of the independent elastic constants in current Strain
            The sequence is in order of the index, e.g. for cubicI, [111, 112, 123, 144, 155, 456]
    '''
    (StrainOrd, StrainOrdCoef) = gen_strainord(Strain)
    CijkInd = symdata.coef_ind(CrystalType, Ord)
    CoefCoef = symdata.coef_crystal(CrystalType, Ord)                
    (Cijk, CijkCoef) = gen_strain_coef(StrainOrd, StrainOrdCoef, Ord)
    CijkUniq = np.array(symdata.get_unique(CijkInd))
    CoefStrain = np.zeros(len(CijkUniq))
    CijkNum = cijk2num(Cijk, Ord)
    for i in range(0, len(CijkNum)):
        COrderi = CijkInd[CijkNum[i]]
        if type(COrderi) is list:
            for j in range(0, len(COrderi)):
                CoefOrderi = float(CoefCoef[CijkNum[i]][j]) * float(CijkCoef[i])
                Index_CoefStrain = np.argwhere(CijkUniq == COrderi[j])
                Index_CoefStrain = Index_CoefStrain[0][0]
                CoefStrain[Index_CoefStrain] = CoefStrain[Index_CoefStrain] + CoefOrderi
        else:
            if COrderi != 0:
                CoefOrderi = float(CoefCoef[CijkNum[i]]) * float(CijkCoef[i])
                Index_CoefStrain = np.argwhere(CijkUniq == COrderi)
                #print Index_CoefStrain
                Index_CoefStrain = Index_CoefStrain[0][0]
                CoefStrain[Index_CoefStrain] = CoefStrain[Index_CoefStrain] + CoefOrderi
    return CoefStrain

def gen_strain_mode(CrystalType='c1', Ord=3):
    '''
    Generate the strain mode for give symmetry and order
    Parameter
    ---------
        CrystalType: str
            The crystal type, in Laue group
        Ord: int
            The order of elastic constants
    Return
    ------
        StrainModeCoef: elastic3rd.symmetry.symmetry.CoefStr object
            elastic3rd defined coefficients object
                It contains several attributes. 
                    e.g. CoefStr.coef2, CoefStr.coef3, ..., CoefStr.coefn, ...
                    Here n equal to Ord
                In each attributes, it is a 2D np.ndarray
        StrainMode: 3D np.ndarray
            The strain mode in matrix/tesnsor format
                size: nx3x3, here n is the number of strain modes
    '''
    StrainAll = gen_strain(1)
    CijkInd = symdata.coef_ind(CrystalType, Ord)
    CoefCoef = symdata.coef_crystal(CrystalType, Ord)
    CijkUniq = np.array(symdata.get_unique(CijkInd))
    n_uniq = len(CijkUniq)
    Cijk = num2cijk(CijkUniq, Ord)
    StrainMode = np.zeros((n_uniq, 3, 3), dtype = float)

    StrainModeCoef = CoefStr(Ord)
    exec('StrainModeCoef.coef' + str(int(Ord)) + ' = np.zeros((n_uniq, n_uniq), dtype = float)')
    for i in range(2, int(Ord)):
        CijUniq = np.array(symdata.get_unique(symdata.coef_ind(CrystalType, i)))
        n_uniqi = len(CijUniq)
        exec('StrainModeCoef.coef' + str(i) + ' = np.zeros((n_uniq, n_uniqi), dtype = float)')
    count = 0
    for i in range(0, len(StrainAll)):
        Straini = crydef.vec2matrix(StrainAll[i])
        StrainModei = gen_cijk_coef(CrystalType, Straini, Ord)
        if i == 0:
            StrainMode[count, :, :] = Straini
            exec('StrainModeCoef.coef' + str(int(Ord)) + '[count, :] = StrainModei')
            for j in range(2, int(Ord)):
                exec('StrainModeCoef.coef' + str(j) + '[count, :] = gen_cijk_coef(CrystalType, Straini, j)')               
            count = count + 1
        else:
            StrainModetmp = np.zeros((count + 1, n_uniq), dtype = float)
            StrainModetmp[0:count, :] = eval('StrainModeCoef.coef' + str(int(Ord)) + '[0:count, :]')
            StrainModetmp[count, :] = StrainModei
            SMRank = np.linalg.matrix_rank(StrainModetmp)
            if SMRank == count + 1:
                exec('StrainModeCoef.coef' + str(int(Ord)) + '[count, :] = StrainModei')
                StrainMode[count, :, :] = Straini
                for j in range(2, int(Ord)):
                    exec('StrainModeCoef.coef' + str(j) + '[count, :] = gen_cijk_coef(CrystalType, Straini, j)') 
                count = count + 1
                if count == n_uniq:
                    break
    return (StrainModeCoef, StrainMode)

def gen_cijall(Ord=3):
    '''
    Generate all elastic constants according Ord
    Parameter
    ---------
        Ord: int
            Then order of elastic constants
    Return
    ------
        CijkAll: list
            The list of all elastic constants (upper triangle of tensor)
                e.g. Ord=2, CijAll=[11,12,13,14,15,16,22,23,24,25,26,33,34,35,36,44,45,46,55,56,66]
    '''
    N = int(6 ** Ord)
    CijkAll = np.zeros(N, dtype=int)
    for i in range(0, N):
        IJK = Num2IJK(i + 1, 6, int(Ord))
        IJK = np.sort(IJK)
        for j in range(0, int(Ord)):
            CijkAll[i] = CijkAll[i] + IJK[j] * (10 ** (Ord - 1 - j))
    CijkAll = np.unique(CijkAll)
    return CijkAll

def cijk2num(Cijk, Ord=3):
    '''
    Convert cijk into number
    Parameter
    ---------
        Cijk: int/list
            The list of the index of elasti constants, e.g. 111, [111, 123]
                Note: the sequece of each index should in order of increase
                    e.g. 123 should be 123 (231 or 132 won't work)
        Ord: int
            The order of elastic constants
    Return
    ------
        CijkNum: list
            The index order of Cijk, e.g. 123->7
                Note: The first elements is 0 not 1
    '''
    CijkAll = gen_cijall(Ord)
    CijkNum = []
    if type(Cijk) is int or type(Cijk) is float:
        Cijk = [Cijk]
    for i in Cijk:
        indexi = np.argwhere(CijkAll == i)
        CijkNum.append(indexi[0][0])
    return CijkNum

def num2cijk(num, Ord=3):
    '''
    Convert number to cijk index
    Parameter
    ---------
        num: int/np.ndarray
            The number of the index of the elastic constants, e.g. 111->1, 123->8
                Note: num start from 1, not 0 (different with cijk2num)
                      list won't work
        Ord: int
            The order of elastic constants
    Return
    ------
        Cijk: int/np.ndarray
            The index of elastic constants, e.g. 111, 123, ...
    '''
    CijkAll = gen_cijall(Ord)
    Cijk = CijkAll[num - 1]
    return Cijk

def CoefForSingleMode(CrystalType='c1', Ord=3, Strain=np.array([[0.5,-2,-0.5,1,1,0]])):
    '''
    Generate the coefficient for specified strain modes
    Parameter
    ---------
        CrystalType: str
            The crystal type (symmetry), in Laue's group
        Ord: int
            The order of elastic constants
        Strain: 2D np.ndarray
            The strain modes, support multi-strain modes
                Note: in Voigt's notation and the size is nx6
                      e.g. np.array([[1, 1, 0, 2, 0, 0]])
    Return
    ------
        Cijk: elastic3rd.symmetry.symmetry.CoefStr object
            The independent elastic constants (in Ord order)
        StrainModeCoef: elastic3rd.symmetry.symmetry.CoefStr object
            The coefficients of independent elastic constants
        StrainMode: 3D np.ndarray
            The strain modes nx3x3
    '''
    m = Strain.shape
    if len(m) == 1:
        m = 1
    else:
        m = m[0]
    StrainMode = np.zeros((m, 3, 3))
    StrainModeCoef = CoefStr(Ord)
    for i in range(2, int(Ord) + 1):
        CijUniq = np.array(symdata.get_unique(symdata.coef_ind(CrystalType, i)))
        n_uniq = len(CijUniq)
        exec('StrainModeCoef.coef' + str(i) + ' = np.zeros((m, n_uniq), dtype = float)')
    #StrainModeCoef = CoefStr(Ord)
    Cijk = CoefStr(Ord)
    for i in range(2, int(Ord) + 1):
        exec('Cijk.coef' + str(i) + ' = print_cijk(CrystalType, i)')
        for j in range(0, m):
            StrainM = crydef.vec2matrix(Strain[j, :])
            StrainMode[j, :, :] = StrainM
            #print StrainM
            exec('StrainModeCoef.coef' + str(i) + '[j, :] = gen_cijk_coef(CrystalType, StrainM, i)')
        exec('print(StrainModeCoef.coef' + str(i) + ')')
    return (Cijk, StrainModeCoef, StrainMode)

def print_cijk(CrystalType='c1', Ord=3):
    '''
    Print independent Cijk according to the crystal type and order
    Parameter
    ---------
        CrystalType: str
            The crystal type (symmetry), in Laue's group
        Ord: int
            The order of elastic constants
    Return
    ------
        Cijk: np.ndarray
            The list of Cijk (order is determined by Ord)
    '''
    CijkInd = symdata.coef_ind(CrystalType, Ord)
    CijkUniq = np.array(symdata.get_unique(CijkInd))
    Cijk = num2cijk(CijkUniq, Ord)
    print(Cijk)
    return Cijk

class CoefStr:
    """
    This is the structure for coefficients. The attributes is coef + i, 
        where i is 2 to Ord
    Take Ord = 3 as an example, there are two attributes, coef2 and coef3
    """
    def __init__(self, Ord = 3):
        for i in range(2, int(Ord) + 1):
            exec('self.coef' + str(i) + ' = []')      
